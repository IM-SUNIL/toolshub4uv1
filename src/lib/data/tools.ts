
// In a real application, this data will come from the MongoDB database via API calls.
// For now, these functions act as placeholders.

import type { LucideIcon } from 'lucide-react';
import { Zap, FileText, Scissors, Video, Code, Star, StarHalf } from 'lucide-react';
import * as React from 'react';

// Define Tool and Comment types based on Mongoose schemas
export interface Comment {
    // Assuming MongoDB automatically adds _id
    _id?: string; // Optional because it's generated by MongoDB
    name: string;
    comment: string;
    timestamp: string; // Store as ISO string or Date
}

export interface Tool {
    _id: string; // MongoDB ID
    slug: string;
    name: string;
    image?: string;
    categorySlug: string;
    isFree: boolean;
    rating: number;
    summary: string;
    description: string;
    usageSteps: { text: string }[]; // Assuming steps are objects with 'text'
    websiteLink: string;
    tags: string[];
    comments: Comment[];
    relatedToolIds?: string[];
    createdAt: string; // Store as ISO string or Date
    updatedAt: string; // Store as ISO string or Date
}

// Define Category type based on Mongoose schema
export interface Category {
  _id: string; // MongoDB ID
  slug: string;
  name: string;
  description: string;
  iconName: string; // Store the name like "Zap", "FileText"
  imageURL?: string;
  tags: string[];
  createdAt: string; // Store as ISO string or Date
}

// Map icon names to Lucide components
export const iconMap: { [key: string]: LucideIcon } = {
    Zap,
    FileText,
    Scissors,
    Video,
    Code,
    // Add more mappings as needed
};

// --- API Endpoints ---
// Use relative paths which will be resolved by Next.js/Firebase rewrites
const API_BASE_URL = '/api'; // Assuming Firebase rewrite proxies /api to your function
const TOOLS_API_ENDPOINT = `${API_BASE_URL}/tools`;
const CATEGORIES_API_ENDPOINT = `${API_BASE_URL}/categories`;


// --- Data Fetching Functions (using fetch API) ---

// Fetch all tools
export const getAllTools = async (): Promise<Tool[]> => {
    try {
        const response = await fetch(TOOLS_API_ENDPOINT);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data: Tool[] = await response.json();
        return data;
    } catch (error) {
        console.error("Error fetching all tools:", error);
        return []; // Return empty array on error
    }
};

// Fetch a single tool by slug
export const getToolBySlug = async (slug: string): Promise<Tool | null> => {
    try {
        const response = await fetch(`${TOOLS_API_ENDPOINT}/${slug}`);
        if (!response.ok) {
            if (response.status === 404) return null; // Not found
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data: Tool = await response.json();
        return data;
    } catch (error) {
        console.error(`Error fetching tool with slug ${slug}:`, error);
        return null; // Return null on error
    }
};

// Fetch all categories
export const getAllCategories = async (): Promise<Category[]> => {
    try {
        const response = await fetch(CATEGORIES_API_ENDPOINT);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data: Category[] = await response.json();
        return data;
    } catch (error) {
        console.error("Error fetching all categories:", error);
        return []; // Return empty array on error
    }
};

// Fetch tools by category slug
export const getToolsByCategorySlug = async (categorySlug: string): Promise<Tool[]> => {
    try {
        const response = await fetch(`${CATEGORIES_API_ENDPOINT}/${categorySlug}/tools`);
        if (!response.ok) {
             if (response.status === 404) return []; // Category not found or no tools
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data: Tool[] = await response.json();
        return data;
    } catch (error) {
        console.error(`Error fetching tools for category ${categorySlug}:`, error);
        return []; // Return empty array on error
    }
};

// Add a comment to a tool
export const addCommentToTool = async (toolSlug: string, name: string, comment: string): Promise<Comment | null> => {
    try {
        const response = await fetch(`${TOOLS_API_ENDPOINT}/${toolSlug}/comments`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ name, comment }),
        });
         const result = await response.json(); // Read the body regardless of status
        if (!response.ok) {
            throw new Error(result.msg || `HTTP error! status: ${response.status}`);
        }
        // Assuming the backend returns the newly added comment object
        return result.comment as Comment;
    } catch (error) {
        console.error(`Error adding comment to tool ${toolSlug}:`, error);
        return null;
    }
};

// Fetch comments for a tool
export const getCommentsForTool = async (toolSlug: string): Promise<Comment[]> => {
    try {
        const response = await fetch(`${TOOLS_API_ENDPOINT}/${toolSlug}/comments`);
        if (!response.ok) {
            if (response.status === 404) return []; // Tool not found
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data: Comment[] = await response.json();
        return data;
    } catch (error) {
        console.error(`Error fetching comments for tool ${toolSlug}:`, error);
        return [];
    }
};


// --- Helper Functions (Keep as before or adapt if needed) ---

// Get Lucide icon component based on stored name string
export const getIconComponent = (iconName: string): LucideIcon => {
    return iconMap[iconName] || Zap; // Default to Zap if not found
};


// Render star ratings (using React.createElement for TS files)
export const renderStars = (rating: number): React.ReactNode[] => {
  const fullStars = Math.floor(rating);
  const halfStar = rating % 1 >= 0.5;
  const emptyStars = 5 - fullStars - (halfStar ? 1 : 0);
  const stars: React.ReactNode[] = [];

  for (let i = 0; i < fullStars; i++) {
    stars.push(React.createElement(Star, { key: `full-${i}`, className: "h-5 w-5 fill-yellow-400 text-yellow-400" }));
  }
  if (halfStar) {
    stars.push(React.createElement(StarHalf, { key: "half", className: "h-5 w-5 fill-yellow-400 text-yellow-400" }));
  }
  for (let i = 0; i < emptyStars; i++) {
    stars.push(React.createElement(Star, { key: `empty-${i}`, className: "h-5 w-5 text-muted-foreground" }));
  }
  return stars;
};

// Note: Functions like `getFeaturedTools` and `getRelatedTools` would now also
// likely involve API calls or filtering the results from `getAllTools`.
// Example placeholder for featured tools (adapt based on your API structure)
export const getFeaturedTools = async (): Promise<Tool[]> => {
    const allTools = await getAllTools();
    // Implement logic to determine "featured" tools (e.g., based on rating, tag, etc.)
    return allTools.slice(0, 6); // Simple example: first 6 tools
};

// Example placeholder for related tools
export const getRelatedTools = async (tool: Tool): Promise<Tool[]> => {
    // Fetch tools from the same category, excluding the current tool
    const categoryTools = await getToolsByCategorySlug(tool.categorySlug);
    return categoryTools.filter(t => t._id !== tool._id).slice(0, 3); // Example: 3 related tools
};
