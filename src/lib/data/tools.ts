
// In a real application, this data will come from the MongoDB database via API calls.
// For now, these functions act as placeholders.

import type { LucideIcon } from 'lucide-react';
import { Zap, FileText, Scissors, Video, Code, Star, StarHalf } from 'lucide-react';
import * as React from 'react';

// Define Tool and Comment types based on Mongoose schemas
export interface Comment {
    // Assuming MongoDB automatically adds _id
    _id?: string; // Optional because it's generated by MongoDB
    name: string;
    comment: string;
    timestamp: string; // Store as ISO string or Date
}

export interface Tool {
    _id: string; // MongoDB ID
    slug: string;
    name: string;
    image?: string;
    categorySlug: string;
    isFree: boolean;
    rating: number;
    summary: string;
    description: string;
    usageSteps: { text: string }[]; // Assuming steps are objects with 'text'
    websiteLink: string;
    tags: string[];
    comments: Comment[];
    relatedToolIds?: string[];
    createdAt: string; // Store as ISO string or Date
    updatedAt: string; // Store as ISO string or Date
}

// Define Category type based on Mongoose schema
export interface Category {
  _id: string; // MongoDB ID
  slug: string;
  name: string;
  description: string;
  iconName: string; // Store the name like "Zap", "FileText"
  imageURL?: string;
  tags: string[];
  createdAt: string; // Store as ISO string or Date
}

// Map icon names to Lucide components
export const iconMap: { [key: string]: LucideIcon } = {
    Zap,
    FileText,
    Scissors,
    Video,
    Code,
    // Add more mappings as needed
};

// --- API Endpoints ---
// Base URL for the Firebase Cloud Functions API.
// It MUST be set in the environment variables (.env.local for local dev, Vercel/Firebase env vars for deployment).
const API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL;

if (!API_BASE_URL) {
    console.warn(
        '\x1b[33m%s\x1b[0m', // Yellow text
        'Warning: NEXT_PUBLIC_API_BASE_URL environment variable is not set.'
    );
    console.warn(
        'API calls may fail. For local development with Firebase emulators, set it in .env.local:',
        '\nNEXT_PUBLIC_API_BASE_URL=http://127.0.0.1:5001/toolshub4u/us-central1/api'
    );
    console.warn(
        'For deployment, set this variable in your hosting provider\'s environment settings.'
    );
}

// Helper function to create absolute URLs for fetch
// Necessary for server-side fetch calls (SSR, SSG, Server Components)
const getAbsoluteUrl = (path: string): string => {
    // If path already starts with http, assume it's absolute
    if (path.startsWith('http')) {
        return path;
    }
    // If API_BASE_URL is not set, relative paths might work client-side but fail server-side.
    if (!API_BASE_URL) {
        console.error("API_BASE_URL is not defined. Relative path used:", path);
        return path; // Fallback to relative path, may cause issues server-side
    }
    // Ensure no double slashes
    return `${API_BASE_URL.replace(/\/$/, '')}/${path.replace(/^\//, '')}`;
};

// --- Data Fetching Functions (using fetch API) ---

// Fetch all tools
export const getAllTools = async (): Promise<Tool[]> => {
    try {
        const url = getAbsoluteUrl('/tools');
        console.log(`Fetching all tools from: ${url}`); // Log the URL being fetched
        const response = await fetch(url);
        if (!response.ok) {
            const errorText = await response.text(); // Get more details on the error
            throw new Error(`HTTP error! status: ${response.status} fetching ${url}. Response: ${errorText}`);
        }
        const data: Tool[] = await response.json();
        return data;
    } catch (error) {
        console.error("Error fetching all tools:", error);
        // Re-throw the error or return empty array depending on desired behavior
        // throw error; // Option 1: Re-throw to let caller handle it
        return []; // Option 2: Return empty array on error
    }
};

// Fetch a single tool by slug
export const getToolBySlug = async (slug: string): Promise<Tool | null> => {
    try {
        const url = getAbsoluteUrl(`/tools/${slug}`);
        console.log(`Fetching tool by slug from: ${url}`); // Log the URL
        const response = await fetch(url);
        if (!response.ok) {
            if (response.status === 404) return null; // Not found is a valid case
            const errorText = await response.text();
            throw new Error(`HTTP error! status: ${response.status} fetching ${url}. Response: ${errorText}`);
        }
        const data: Tool = await response.json();
        return data;
    } catch (error) {
        console.error(`Error fetching tool with slug ${slug}:`, error);
        return null; // Return null on error
    }
};

// Fetch all categories
export const getAllCategories = async (): Promise<Category[]> => {
    try {
        const url = getAbsoluteUrl('/categories');
        console.log(`Fetching all categories from: ${url}`); // Log the URL
        const response = await fetch(url);
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP error! status: ${response.status} fetching ${url}. Response: ${errorText}`);
        }
        const data: Category[] = await response.json();
        return data;
    } catch (error) {
        console.error("Error fetching all categories:", error);
        return []; // Return empty array on error
    }
};

// Fetch tools by category slug
export const getToolsByCategorySlug = async (categorySlug: string): Promise<Tool[]> => {
    try {
        const url = getAbsoluteUrl(`/categories/${categorySlug}/tools`);
        console.log(`Fetching tools by category from: ${url}`); // Log the URL
        const response = await fetch(url);
        if (!response.ok) {
             if (response.status === 404) return []; // Category not found or no tools is valid
            const errorText = await response.text();
            throw new Error(`HTTP error! status: ${response.status} fetching ${url}. Response: ${errorText}`);
        }
        const data: Tool[] = await response.json();
        return data;
    } catch (error) {
        console.error(`Error fetching tools for category ${categorySlug}:`, error);
        return []; // Return empty array on error
    }
};

// Add a comment to a tool (this might be called client-side, relative URL is ok)
// Let's keep this relative as it's likely called only from the client ToolDetailClient component
export const addCommentToTool = async (toolSlug: string, name: string, comment: string): Promise<Comment | null> => {
    try {
        // Use relative URL as this function is likely called from client-side components
        const url = `/api/tools/${toolSlug}/comments`;
        console.log(`Adding comment via: ${url}`); // Log the URL
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ name, comment }),
        });
         const result = await response.json(); // Read the body regardless of status
        if (!response.ok) {
            throw new Error(result.msg || `HTTP error! status: ${response.status}`);
        }
        // Assuming the backend returns the newly added comment object
        return result.comment as Comment;
    } catch (error) {
        console.error(`Error adding comment to tool ${toolSlug}:`, error);
        return null;
    }
};

// Fetch comments for a tool (likely called client-side, relative URL ok)
export const getCommentsForTool = async (toolSlug: string): Promise<Comment[]> => {
    try {
        // Use relative URL as this function is likely called from client-side components
        const url = `/api/tools/${toolSlug}/comments`;
        console.log(`Fetching comments from: ${url}`); // Log the URL
        const response = await fetch(url);
        if (!response.ok) {
            if (response.status === 404) return []; // Tool not found is valid
            const errorText = await response.text();
            throw new Error(`HTTP error! status: ${response.status} fetching ${url}. Response: ${errorText}`);
        }
        const data: Comment[] = await response.json();
        return data;
    } catch (error) {
        console.error(`Error fetching comments for tool ${toolSlug}:`, error);
        return [];
    }
};


// --- Helper Functions (Keep as before or adapt if needed) ---

// Get Lucide icon component based on stored name string
export const getIconComponent = (iconName: string): LucideIcon => {
    return iconMap[iconName] || Zap; // Default to Zap if not found
};


// Render star ratings (using React.createElement for TS files)
export const renderStars = (rating: number): React.ReactNode[] => {
  const fullStars = Math.floor(rating);
  const halfStar = rating % 1 >= 0.5;
  const emptyStars = 5 - fullStars - (halfStar ? 1 : 0);
  const stars: React.ReactNode[] = [];

  for (let i = 0; i < fullStars; i++) {
    stars.push(React.createElement(Star, { key: `full-${i}`, className: "h-5 w-5 fill-yellow-400 text-yellow-400" }));
  }
  if (halfStar) {
    stars.push(React.createElement(StarHalf, { key: "half", className: "h-5 w-5 fill-yellow-400 text-yellow-400" }));
  }
  for (let i = 0; i < emptyStars; i++) {
    stars.push(React.createElement(Star, { key: `empty-${i}`, className: "h-5 w-5 text-muted-foreground" }));
  }
  return stars;
};

// Note: Functions like `getFeaturedTools` and `getRelatedTools` would now also
// likely involve API calls or filtering the results from `getAllTools`.
// Example placeholder for featured tools (adapt based on your API structure)
export const getFeaturedTools = async (): Promise<Tool[]> => {
    const allTools = await getAllTools();
    // Implement logic to determine "featured" tools (e.g., based on rating, tag, etc.)
    return allTools.sort((a, b) => b.rating - a.rating).slice(0, 6); // Simple example: top 6 rated tools
};

// Example placeholder for related tools
export const getRelatedTools = async (tool: Tool): Promise<Tool[]> => {
    // Fetch tools from the same category, excluding the current tool
    const categoryTools = await getToolsByCategorySlug(tool.categorySlug);
    return categoryTools.filter(t => t._id !== tool._id).slice(0, 3); // Example: 3 related tools
};
