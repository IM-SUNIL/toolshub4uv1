
const express = require('express');
const router = express.Router();
const Tool = require('../models/Tool'); // Adjust path as needed

// @route   POST /api/tools/add
// @desc    Add a new tool
// @access  Public (consider adding auth later)
router.post('/add', async (req, res) => {
  console.log("Received data for new tool:", req.body); // Log received data

  // Basic validation (Mongoose schema validation handles more)
  const { name, slug, categorySlug, summary, description, websiteLink } = req.body;
  if (!name || !slug || !categorySlug || !summary || !description || !websiteLink) {
    return res.status(400).json({ success: false, data: null, error: 'Please include all required fields: name, slug, categorySlug, summary, description, websiteLink' });
  }

  try {
    // Check if tool with the same slug already exists
    let tool = await Tool.findOne({ slug: req.body.slug });
    if (tool) {
      return res.status(400).json({ success: false, data: null, error: `Tool with slug '${req.body.slug}' already exists.` });
    }

    // Create a new tool instance from the request body
    tool = new Tool({
        ...req.body // Spread all fields from the request body
        // Ensure fields match the Tool schema; Mongoose will ignore extras
    });

    // Save the tool to the database
    await tool.save();
    console.log("Tool saved successfully:", tool);
    res.status(201).json({ success: true, data: tool, error: null });

  } catch (err) {
    console.error("Error saving tool:", err.message);
    // Handle validation errors specifically if needed
     if (err.name === 'ValidationError') {
         // Extract validation messages
         const messages = Object.values(err.errors).map(val => val.message);
         return res.status(400).json({ success: false, data: null, error: `Validation Error: ${messages.join(', ')}` });
     }
    res.status(500).json({ success: false, data: null, error: 'Server Error while saving tool.'});
  }
});

// @route   GET /api/tools
// @desc    Get all tools
// @access  Public
router.get('/', async (req, res) => {
  try {
    const tools = await Tool.find().sort({ createdAt: -1 }); // Sort by newest first
    res.json({ success: true, data: tools, error: null });
  } catch (err) {
    console.error(err.message);
    res.status(500).json({ success: false, data: null, error: 'Server Error while fetching tools.' });
  }
});

// @route   GET /api/tools/:slug
// @desc    Get a single tool by its slug
// @access  Public
router.get('/:slug', async (req, res) => {
  try {
    const tool = await Tool.findOne({ slug: req.params.slug });
    // Optional: Populate category details if needed
    // .populate('categorySlug', 'name iconName');

    if (!tool) {
      return res.status(404).json({ success: false, data: null, error: 'Tool not found' });
    }
    res.json({ success: true, data: tool, error: null });
  } catch (err) {
    console.error(err.message);
    // if (err.kind === 'ObjectId') { // Handle invalid ID format if using ObjectId
    //    return res.status(404).json({ success: false, data: null, error: 'Tool not found (invalid ID format)' });
    //  }
    res.status(500).json({ success: false, data: null, error: 'Server Error while fetching tool.' });
  }
});


// @route   POST /api/tools/:toolSlug/comments
// @desc    Add a comment to a specific tool (using embedded comments)
// @access  Public (consider auth)
router.post('/:toolSlug/comments', async (req, res) => {
    const { name, comment } = req.body;
    const toolSlug = req.params.toolSlug;

    if (!name || !comment) {
        return res.status(400).json({ success: false, data: null, error: 'Name and comment are required.' });
    }

    try {
        const tool = await Tool.findOne({ slug: toolSlug });

        if (!tool) {
            return res.status(404).json({ success: false, data: null, error: 'Tool not found.' });
        }

        const newComment = {
            name: name,
            comment: comment,
            timestamp: new Date()
            // id is automatically generated by MongoDB within the array
        };

        tool.comments.push(newComment); // Add to the embedded array
        await tool.save(); // Save the parent tool document

        // Return only the newly added comment or the whole tool's comments
        // Find the newly added comment (MongoDB adds _id automatically)
        const addedComment = tool.comments[tool.comments.length - 1];

        res.status(201).json({ success: true, data: addedComment, error: null });

    } catch (err) {
        console.error("Error adding comment:", err.message);
        res.status(500).json({ success: false, data: null, error: 'Server Error while adding comment.' });
    }
});

// @route   GET /api/tools/:toolSlug/comments
// @desc    Get all comments for a specific tool (using embedded comments)
// @access  Public
router.get('/:toolSlug/comments', async (req, res) => {
    const toolSlug = req.params.toolSlug;

    try {
        const tool = await Tool.findOne({ slug: toolSlug }).select('comments'); // Select only the comments field

        if (!tool) {
            return res.status(404).json({ success: false, data: null, error: 'Tool not found.' });
        }

        res.json({ success: true, data: tool.comments || [], error: null }); // Return the comments array or an empty array

    } catch (err) {
        console.error("Error fetching comments:", err.message);
        res.status(500).json({ success: false, data: null, error: 'Server Error while fetching comments.' });
    }
});


// Add routes for updating and deleting tools as needed

module.exports = router;
